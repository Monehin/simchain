use anchor_lang::prelude::*;
use anchor_lang::solana_program::sysvar;
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{self, Mint, Token, TokenAccount, Transfer},
};

declare_id!("DMaWHy1YmFNNKhyMWaTGpY76hKPdAhu4ExMHTGHU2j8r");

/// Shared CPI guard macro to avoid duplication
macro_rules! no_cpi {
    ($ctx:expr) => {
        guard_no_cpi(&$ctx.accounts.instructions)?
    };
}

/// Maximum salt length to prevent excessive Config account size
pub const MAX_SALT_LENGTH: usize = 32;

/// Account discriminators (first 8 bytes of serialized accounts)
/// These values are generated by Anchor and should match the IDL
/// 
/// IMPORTANT: Always use discriminators instead of data_len for account type identification
/// 
/// Why discriminators are better than data_len:
/// 1. data_len can change when account structure changes (adding/removing fields)
/// 2. Multiple account types could have the same data_len, leading to false positives
/// 3. Discriminators are unique per account type and stable across program versions
/// 4. Discriminators provide O(1) account type verification
/// 
/// Usage example:
/// ```rust
/// if is_wallet_account(&account_info) {
///     // Safe to deserialize as Wallet
///     let wallet = Wallet::try_deserialize(&mut &account_info.data.borrow()[..])?;
/// }
/// ```
pub const WALLET_DISCRIMINATOR: [u8; 8] = [24, 89, 59, 139, 81, 154, 232, 95];
pub const CONFIG_DISCRIMINATOR: [u8; 8] = [155, 12, 170, 224, 30, 250, 204, 130];
pub const MINT_REGISTRY_DISCRIMINATOR: [u8; 8] = [253, 5, 199, 161, 2, 189, 45, 165];
pub const ALIAS_INDEX_DISCRIMINATOR: [u8; 8] = [122, 40, 47, 157, 153, 82, 76, 31];

/// Check if an account is a Wallet by verifying its discriminator
/// This is more reliable than checking data_len which can change
pub fn is_wallet_account(account_info: &AccountInfo) -> bool {
    if account_info.data_len() < 8 {
        return false;
    }
    
    let data = account_info.data.borrow();
    let discriminator = &data[..8];
    
    discriminator == WALLET_DISCRIMINATOR
}

/// Check if an account is a Config by verifying its discriminator
pub fn is_config_account(account_info: &AccountInfo) -> bool {
    if account_info.data_len() < 8 {
        return false;
    }
    
    let data = account_info.data.borrow();
    let discriminator = &data[..8];
    
    discriminator == CONFIG_DISCRIMINATOR
}

/// Check if an account is a MintRegistry by verifying its discriminator
pub fn is_mint_registry_account(account_info: &AccountInfo) -> bool {
    if account_info.data_len() < 8 {
        return false;
    }
    
    let data = account_info.data.borrow();
    let discriminator = &data[..8];
    
    discriminator == MINT_REGISTRY_DISCRIMINATOR
}

/// Check if an account is an AliasIndex by verifying its discriminator
pub fn is_alias_index_account(account_info: &AccountInfo) -> bool {
    if account_info.data_len() < 8 {
        return false;
    }
    
    let data = account_info.data.borrow();
    let discriminator = &data[..8];
    
    discriminator == ALIAS_INDEX_DISCRIMINATOR
}

/// Validate alias format on-chain
fn validate_alias(alias: &[u8; 32]) -> Result<()> {
    // Check that alias is not all zeros
    require!(
        alias.iter().any(|&b| b != 0),
        SimchainError::InvalidAlias
    );
    
    // Check that alias contains only printable ASCII characters
    require!(
        alias.iter().all(|&b| b == 0 || (b >= 32 && b <= 126)),
        SimchainError::InvalidAlias
    );
    
    Ok(())
}

/// Validate salt length to prevent excessive account size
fn validate_salt(salt: &[u8]) -> Result<()> {
    require!(
        salt.len() <= MAX_SALT_LENGTH,
        SimchainError::InvalidSaltLength
    );
    Ok(())
}

// Event definitions for off-chain observability
#[event]
pub struct RegistryInitialized {
    pub admin: Pubkey,
}

#[event]
pub struct WalletInitialized {
    pub wallet: Pubkey,
    pub owner: Pubkey,
}

#[event]
pub struct MintAdded {
    pub mint: Pubkey,
    pub admin: Pubkey,
}

#[event]
pub struct NativeTransfer {
    pub from: Pubkey,
    pub to: Pubkey,
    pub amount: u64,
    pub transfer_type: String, // "deposit", "withdraw", or "send"
}

#[event]
pub struct TokenTransfer {
    pub from_wallet: Pubkey,
    pub to_wallet: Pubkey,
    pub mint: Pubkey,
    pub amount: u64,
}

#[event]
pub struct WalletClosed {
    pub wallet: Pubkey,
    pub owner: Pubkey,
    pub rent_reclaimed: u64,
}

#[event]
pub struct AdminTransferred {
    pub old_admin: Pubkey,
    pub new_admin: Pubkey,
}

#[event]
pub struct SaltRotated {
    pub admin: Pubkey,
    /// SHA256(salt) so clients can update without embedding the full secret
    /// This prevents event bloat and keeps the raw salt private
    pub new_salt_hash: [u8; 32],
}

#[event]
pub struct AliasSet {
    pub wallet: Pubkey,
    pub alias: [u8; 32],
}

#[event]
pub struct AliasCleared {
    pub wallet: Pubkey,
    pub alias: [u8; 32],
}

#[event]
pub struct HealthCheckEvent {
    pub wallet_count: u64,
}

#[program]
pub mod simchain_wallet {
    use super::*;

    /// Initialize the global configuration with salt for wallet derivation
    /// 
    /// # Arguments
    /// * `salt` - Cryptographic salt for wallet PDA derivation (max 32 bytes)
    pub fn initialize_config(ctx: Context<InitializeConfig>, salt: Vec<u8>) -> Result<()> {
        no_cpi!(ctx);
        
        // Validate salt length
        validate_salt(&salt)?;
        
        let config = &mut ctx.accounts.config;
        config.admin = ctx.accounts.admin.key();
        config.salt = salt.clone();
        config.bump = ctx.bumps.config;
        
        emit!(SaltRotated {
            admin: ctx.accounts.admin.key(),
            new_salt_hash: hash_salt(&salt),
        });
        
        Ok(())
    }

    /// Rotate the salt for enhanced security
    /// 
    /// # Arguments
    /// * `new_salt` - New cryptographic salt (max 32 bytes)
    pub fn rotate_salt(ctx: Context<ModifyConfig>, new_salt: Vec<u8>) -> Result<()> {
        no_cpi!(ctx);
        
        // Validate salt length
        validate_salt(&new_salt)?;
        
        let config = &mut ctx.accounts.config;
        config.salt = new_salt.clone();
        
        emit!(SaltRotated {
            admin: ctx.accounts.admin.key(),
            new_salt_hash: hash_salt(&new_salt),
        });
        
        Ok(())
    }

    /// Transfer admin control to a new admin
    /// 
    /// # Arguments
    /// * `new_admin` - Public key of the new admin
    pub fn transfer_admin(ctx: Context<TransferAdmin>, new_admin: Pubkey) -> Result<()> {
        no_cpi!(ctx);
        let registry = &mut ctx.accounts.registry;
        let old_admin = registry.admin;
        registry.admin = new_admin;
        
        emit!(AdminTransferred {
            old_admin,
            new_admin,
        });
        
        Ok(())
    }

    /// Close the mint registry and reclaim rent (admin only)
    pub fn close_registry(ctx: Context<CloseRegistry>) -> Result<()> {
        no_cpi!(ctx);
        let registry = &ctx.accounts.registry;
        let rent_reclaimed = registry.to_account_info().lamports();
        
        emit!(WalletClosed {
            wallet: registry.key(),
            owner: ctx.accounts.admin.key(),
            rent_reclaimed,
        });
        
        Ok(())
    }

    /// Initialize the global mint registry
    pub fn initialize_registry(ctx: Context<InitializeRegistry>) -> Result<()> {
        no_cpi!(ctx);
        let registry = &mut ctx.accounts.registry;
        registry.admin = ctx.accounts.admin.key();
        registry.approved = Vec::with_capacity(8); // Reduced from 32 to 8 for efficiency
        registry.bump = ctx.bumps.registry;
        registry.wallet_count = 0;
        
        emit!(RegistryInitialized {
            admin: ctx.accounts.admin.key(),
        });
        
        Ok(())
    }

    /// Create the SIM native SPL mint and whitelist it
    /// 
    /// # Arguments
    /// * `_decimals` - Number of decimal places for the mint
    pub fn create_sim_mint(ctx: Context<CreateSimMint>, _decimals: u8) -> Result<()> {
        // Mint is already initialized by Anchor's init_if_needed
        // Just whitelist it
        let reg = &mut ctx.accounts.registry;
        if !reg.approved.contains(&ctx.accounts.sim_mint.key()) {
            reg.approved.push(ctx.accounts.sim_mint.key());
            
            emit!(MintAdded {
                mint: ctx.accounts.sim_mint.key(),
                admin: ctx.accounts.admin.key(),
            });
        }
        Ok(())
    }

    /// Add a new approved mint (admin only)
    /// 
    /// # Arguments
    /// * `new_mint` - Public key of the mint to approve
    pub fn add_mint(ctx: Context<ModifyRegistry>, new_mint: Pubkey) -> Result<()> {
        no_cpi!(ctx);
        let registry = &mut ctx.accounts.registry;
        
        // Check if mint is already approved
        require!(
            !registry.approved.contains(&new_mint),
            SimchainError::MintAlreadyApproved
        );
        
        registry.approved.push(new_mint);
        
        emit!(MintAdded {
            mint: new_mint,
            admin: ctx.accounts.admin.key(),
        });
        
        Ok(())
    }

    /// Initialize a new wallet for a SIM number
    /// 
    /// # Arguments
    /// * `sim` - SIM number string
    /// * `pin_hash` - Hashed PIN (32 bytes)
    pub fn initialize_wallet(
        ctx: Context<InitializeWallet>,
        sim: String,
        pin_hash: [u8; 32],
    ) -> Result<()> {
        no_cpi!(ctx);
        // Only check that pin_hash is not all zeros
        require!(
            pin_hash.iter().any(|&b| b != 0),
            SimchainError::WeakPin
        );
        
        let wallet = &mut ctx.accounts.wallet;
        let registry = &mut ctx.accounts.registry;
        
        wallet.sim_hash = hash_sim_number(&sim, &ctx.accounts.config.salt);
        wallet.owner = ctx.accounts.authority.key();
        wallet.pin_hash = pin_hash;
        wallet.bump = ctx.bumps.wallet;
        wallet.alias = [0u8; 32]; // Initialize with zeros
        
        // Increment wallet counter
        registry.wallet_count = registry.wallet_count.checked_add(1)
            .ok_or(SimchainError::WalletCountOverflow)?;
        
        emit!(WalletInitialized {
            wallet: wallet.key(),
            owner: wallet.owner,
        });
        
        Ok(())
    }

    /// Set an alias for a wallet (scalable O(1) uniqueness checking)
    /// 
    /// # Arguments
    /// * `alias` - 32-byte alias to set for the wallet
    /// 
    /// Uses dedicated alias index PDAs for O(1) collision detection instead of scanning accounts.
    /// This approach scales to any number of wallets without hitting account size limits.
    /// Guaranteed uniqueness: PDA collision prevents duplicate aliases.
    pub fn set_alias(ctx: Context<SetAlias>, alias: [u8; 32]) -> Result<()> {
        no_cpi!(ctx);
        
        // Validate alias format
        validate_alias(&alias)?;
        
        let wallet = &mut ctx.accounts.wallet;
        let alias_index = &mut ctx.accounts.alias_index;
        
        // Check if this wallet already has this alias (no-op)
        if wallet.alias == alias {
            return Ok(());
        }
        
        // Write the reverse-lookup index so no two wallets can ever use the same alias
        alias_index.wallet = wallet.key();
        
        // Finally update the wallet's own alias field
        wallet.alias = alias;
        
        emit!(AliasSet {
            wallet: wallet.key(),
            alias,
        });
        
        Ok(())
    }

    /// Close wallet and reclaim rent
    pub fn close_wallet(ctx: Context<CloseWallet>) -> Result<()> {
        no_cpi!(ctx);
        let wallet = &ctx.accounts.wallet;
        let registry = &mut ctx.accounts.registry;
        let rent_reclaimed = wallet.to_account_info().lamports();
        
        // Emit alias cleared event if wallet had an alias
        if wallet.alias != [0u8; 32] {
            emit!(AliasCleared {
                wallet: wallet.key(),
                alias: wallet.alias,
            });
        }
        
        // Decrement wallet counter
        registry.wallet_count = registry.wallet_count.checked_sub(1)
            .ok_or(SimchainError::WalletCountUnderflow)?;
        
        emit!(WalletClosed {
            wallet: wallet.key(),
            owner: wallet.owner,
            rent_reclaimed,
        });
        
        Ok(())
    }

    /// Close alias index PDA and reclaim rent
    /// This should be called after closing a wallet to free up the alias
    pub fn close_alias_index(ctx: Context<CloseAliasIndex>, alias: [u8; 32]) -> Result<()> {
        no_cpi!(ctx);
        let alias_index = &ctx.accounts.alias_index;
        let _rent_reclaimed = alias_index.to_account_info().lamports();
        
        emit!(AliasCleared {
            wallet: alias_index.wallet,
            alias, // Now we have the original alias for the event
        });
        
        Ok(())
    }

    /// Deposit native SOL into a wallet
    /// 
    /// # Arguments
    /// * `amount` - Amount of SOL to deposit (in lamports)
    /// 
    /// Uses a CPI to the System Program because only the System Program can debit user wallets. Direct lamports mutation is not allowed for accounts not owned by this program.
    pub fn deposit_native(ctx: Context<DepositNative>, amount: u64) -> Result<()> {
        no_cpi!(ctx);
        require!(amount > 0, SimchainError::InvalidAmount);
        
        let wallet = &ctx.accounts.wallet;
        let payer = &ctx.accounts.payer;
        
        // Use CPI to System Program transfer (only System Program can debit user wallets)
        let transfer_ix = anchor_lang::solana_program::system_instruction::transfer(
            &payer.key(),
            &wallet.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &transfer_ix,
            &[
                payer.to_account_info(),
                wallet.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;
        
        emit!(NativeTransfer {
            from: payer.key(),
            to: wallet.key(),
            amount,
            transfer_type: "deposit".to_string(),
        });
        
        Ok(())
    }

    /// Withdraw native SOL from a wallet
    /// 
    /// # Arguments
    /// * `amount` - Amount of SOL to withdraw (in lamports)
    /// 
    /// Uses direct lamports mutation because the wallet PDA is owned by this program.
    pub fn withdraw_native(ctx: Context<WithdrawNative>, amount: u64) -> Result<()> {
        require!(amount > 0, SimchainError::InvalidAmount);
        
        let wallet = &ctx.accounts.wallet;
        let to = &ctx.accounts.to;
        
        // Check wallet balance
        let wallet_balance = wallet.to_account_info().lamports();
        require!(wallet_balance >= amount, SimchainError::InsufficientBalance);
        
        // Ensure destination is a system account (no data)
        require!(to.data_is_empty(), SimchainError::Unauthorized);
        
        // Rent-exemption guard: if not closing, ensure remaining balance >= rent-exempt minimum
        let rent = Rent::get()?;
        let wallet_info = wallet.to_account_info();
        let to_info = to.to_account_info();
        let remaining = wallet_balance - amount;
        let rent_min = rent.minimum_balance(wallet_info.data_len());
        // Allow full withdrawal (for account closure), but otherwise enforce rent-exempt minimum
        if remaining > 0 {
            require!(remaining >= rent_min, SimchainError::InsufficientBalance);
        }
        
        // Direct lamports mutation: our program owns the wallet PDA, so we can modify its lamports
        **wallet_info.try_borrow_mut_lamports()? -= amount;
        **to_info.try_borrow_mut_lamports()? += amount;
        
        emit!(NativeTransfer {
            from: wallet.key(),
            to: to.key(),
            amount,
            transfer_type: "withdraw".to_string(),
        });
        
        Ok(())
    }

    /// Send native SOL between wallets
    /// 
    /// # Arguments
    /// * `amount` - Amount of SOL to send (in lamports)
    /// 
    /// Uses direct lamports mutation because both wallets are PDAs owned by this program.
    pub fn send_native(ctx: Context<SendNative>, amount: u64) -> Result<()> {
        require!(amount > 0, SimchainError::InvalidAmount);
        
        let sender_wallet = &ctx.accounts.sender_wallet;
        let receiver_wallet = &ctx.accounts.receiver_wallet;
        
        // Check sender wallet balance
        let sender_balance = sender_wallet.to_account_info().lamports();
        require!(sender_balance >= amount, SimchainError::InsufficientBalance);
        
        // Rent-exemption guard: if not closing, ensure remaining balance >= rent-exempt minimum
        let rent = Rent::get()?;
        let sender_info = sender_wallet.to_account_info();
        let receiver_info = receiver_wallet.to_account_info();
        let remaining = sender_balance - amount;
        let rent_min = rent.minimum_balance(sender_info.data_len());
        // Allow full transfer (for account closure), but otherwise enforce rent-exempt minimum
        if remaining > 0 {
            require!(remaining >= rent_min, SimchainError::InsufficientBalance);
        }
        
        // Direct lamports mutation: both wallets are PDAs owned by our program
        **sender_info.try_borrow_mut_lamports()? -= amount;
        **receiver_info.try_borrow_mut_lamports()? += amount;
        
        emit!(NativeTransfer {
            from: sender_wallet.key(),
            to: receiver_wallet.key(),
            amount,
            transfer_type: "send".to_string(),
        });
        
        Ok(())
    }

    /// Transfer SPL tokens between wallets
    /// 
    /// # Arguments
    /// * `amount` - Amount of tokens to transfer
    pub fn transfer_token(ctx: Context<TransferToken>, amount: u64) -> Result<()> {
        no_cpi!(ctx);
        require!(amount > 0, SimchainError::InvalidAmount);
        
        let sender_wallet = &ctx.accounts.sender_wallet;
        let receiver_wallet = &ctx.accounts.receiver_wallet;
        let mint = &ctx.accounts.mint;
        let registry = &ctx.accounts.registry;
        
        // Check if mint is approved
        require!(
            registry.approved.contains(&mint.key()),
            SimchainError::MintNotApproved
        );
        
        // Transfer tokens with PDA as signer
        let seeds = &[b"wallet", &sender_wallet.sim_hash[..], &[sender_wallet.bump]];
        let signer = &[&seeds[..]];
        let transfer_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.sender_ata.to_account_info(),
                to: ctx.accounts.receiver_ata.to_account_info(),
                authority: sender_wallet.to_account_info(),
            },
            signer,
        );
        token::transfer(transfer_ctx, amount)?;
        
        emit!(TokenTransfer {
            from_wallet: sender_wallet.key(),
            to_wallet: receiver_wallet.key(),
            mint: mint.key(),
            amount,
        });
        
        Ok(())
    }

    /// Validate PIN against stored hash
    /// 
    /// # Arguments
    /// * `pin_hash` - Hash of the PIN to validate
    pub fn validate_pin(ctx: Context<ValidatePin>, pin_hash: [u8; 32]) -> Result<()> {
        let wallet = &ctx.accounts.wallet;
        
        // Check if the provided PIN hash matches the stored PIN hash
        require!(
            wallet.pin_hash == pin_hash,
            SimchainError::Unauthorized
        );
        
        Ok(())
    }

    /// Check wallet balance (read-only instruction)
    pub fn check_balance(_ctx: Context<CheckBalance>) -> Result<()> {
        // This is a read-only instruction - no state changes
        Ok(())
    }

    /// Health check for monitoring wallet count
    pub fn health_check(ctx: Context<HealthCheck>) -> Result<()> {
        let registry = &ctx.accounts.registry;
        
        emit!(HealthCheckEvent {
            wallet_count: registry.wallet_count,
        });
        
        Ok(())
    }
}

/// Guard against cross-program invocations (CPIs)
fn guard_no_cpi(ix_sysvar: &AccountInfo) -> Result<()> {
    let current_index = anchor_lang::solana_program::sysvar::instructions::load_current_index_checked(ix_sysvar)?;
    if current_index != 0 { 
        return err!(SimchainError::CpiNotAllowed); 
    }
    Ok(())
}

/// Hash SIM number with salt for deterministic PDA derivation
pub fn hash_sim_number(sim: &str, salt: &[u8]) -> [u8; 32] {
    let mut hasher = anchor_lang::solana_program::hash::Hasher::default();
    hasher.hash(sim.as_bytes());
    hasher.hash(salt);
    hasher.result().to_bytes()
}

/// Hash salt for event emission (keeps raw salt private)
pub fn hash_salt(salt: &[u8]) -> [u8; 32] {
    anchor_lang::solana_program::hash::hash(salt).to_bytes()
}

/// Derive the alias index PDA for a given alias
pub fn derive_alias_index_pda(alias: &[u8; 32], program_id: &Pubkey) -> (Pubkey, u8) {
    Pubkey::find_program_address(&[b"alias", alias], program_id)
}

// ── Account Contexts ───────────────────────────────────────────────────
/// Initialize the global configuration
#[derive(Accounts)]
pub struct InitializeConfig<'info> {
    #[account(
        init,
        payer = admin,
        space = Config::INIT_SPACE,
        seeds = [b"config"],
        bump
    )]
    pub config: Account<'info, Config>,
    #[account(mut)] pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
    /// CHECK: sysvar instructions account for CPI guard
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Modify global configuration (admin only)
#[derive(Accounts)]
pub struct ModifyConfig<'info> {
    #[account(
        mut,
        seeds = [b"config"],
        bump = config.bump,
        has_one = admin
    )]
    pub config: Account<'info, Config>,
    pub admin: Signer<'info>,
    /// CHECK: sysvar instructions account for CPI guard
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Transfer admin control to a new admin
#[derive(Accounts)]
pub struct TransferAdmin<'info> {
    #[account(
        mut,
        seeds = [b"mint_registry"],
        bump = registry.bump,
        has_one = admin
    )]
    pub registry: Account<'info, MintRegistry>,
    pub admin: Signer<'info>,
    /// CHECK: sysvar instructions account for CPI guard
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Close the mint registry and reclaim rent (admin only)
#[derive(Accounts)]
pub struct CloseRegistry<'info> {
    #[account(
        mut,
        seeds = [b"mint_registry"],
        bump = registry.bump,
        has_one = admin,
        close = destination
    )]
    pub registry: Account<'info, MintRegistry>,
    pub admin: Signer<'info>,
    /// CHECK: Destination for rent reclamation
    #[account(mut)]
    pub destination: AccountInfo<'info>,
    /// CHECK: sysvar instructions account for CPI guard
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Initialize a new wallet for a SIM number
#[derive(Accounts)]
#[instruction(sim: String, pin_hash: [u8; 32])]
pub struct InitializeWallet<'info> {
    #[account(init, payer = authority, space = Wallet::INIT_SPACE,
              seeds = [b"wallet", &hash_sim_number(&sim, &config.salt)[..]], bump)]
    pub wallet: Account<'info, Wallet>,
    #[account(mut)] pub authority: Signer<'info>,
    #[account(seeds = [b"config"], bump)]
    pub config: Account<'info, Config>,
    #[account(mut, seeds = [b"mint_registry"], bump)]
    pub registry: Account<'info, MintRegistry>,
    pub system_program: Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Set an alias for a wallet (scalable O(1) uniqueness checking)
/// 
/// # Arguments
/// * `alias` - 32-byte alias to set for the wallet
/// 
/// Uses dedicated alias index PDAs for O(1) collision detection instead of scanning accounts.
/// This approach scales to any number of wallets without hitting account size limits.
/// Guaranteed uniqueness: PDA collision prevents duplicate aliases.
#[derive(Accounts)]
#[instruction(alias: [u8; 32])]
pub struct SetAlias<'info> {
    #[account(
        mut,
        seeds = [b"wallet", &wallet.sim_hash[..]],
        bump = wallet.bump,
        has_one = owner
    )]
    pub wallet: Account<'info, Wallet>,
    #[account(mut)]
    pub owner: Signer<'info>,
    /// Alias index PDA for O(1) uniqueness checking
    /// This will fail if an AliasIndex already exists for that alias (guaranteed uniqueness)
    #[account(
        init,
        payer = owner,
        space = AliasIndex::INIT_SPACE,
        seeds = [b"alias", &alias[..]],
        bump
    )]
    pub alias_index: Account<'info, AliasIndex>,
    pub system_program: Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Close wallet and reclaim rent to destination
#[derive(Accounts)]
pub struct CloseWallet<'info> {
    #[account(
        mut,
        seeds = [b"wallet", &wallet.sim_hash[..]], 
        bump = wallet.bump,
        has_one = owner,
        close = destination
    )]
    pub wallet: Account<'info, Wallet>,
    pub owner: Signer<'info>,
    #[account(mut, seeds = [b"mint_registry"], bump)]
    pub registry: Account<'info, MintRegistry>,
    /// CHECK: Destination for rent reclamation
    #[account(mut)]
    pub destination: AccountInfo<'info>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Modify wallet properties (owner only)
#[derive(Accounts)]
pub struct ModifyWallet<'info> {
    #[account(mut,
        seeds = [b"wallet", &wallet.sim_hash[..]], bump = wallet.bump,
        has_one = owner)]
    pub wallet: Account<'info, Wallet>,
    pub owner: Signer<'info>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Deposit native SOL into a wallet
#[derive(Accounts)]
pub struct DepositNative<'info> {
    #[account(mut, seeds = [b"wallet", &wallet.sim_hash[..]], bump = wallet.bump)]
    pub wallet: Account<'info, Wallet>,
    #[account(mut)] pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Withdraw native SOL from a wallet
#[derive(Accounts)]
pub struct WithdrawNative<'info> {
    #[account(mut,
        seeds = [b"wallet", &wallet.sim_hash[..]], bump = wallet.bump,
        has_one = owner)]
    pub wallet: Account<'info, Wallet>,
    pub owner: Signer<'info>,
    /// CHECK: destination system account
    #[account(mut)] pub to: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Send native SOL between wallets
#[derive(Accounts)]
pub struct SendNative<'info> {
    #[account(mut,
        seeds = [b"wallet", &sender_wallet.sim_hash[..]], bump = sender_wallet.bump,
        has_one = owner)]
    pub sender_wallet: Account<'info, Wallet>,
    #[account(mut,
        seeds = [b"wallet", &receiver_wallet.sim_hash[..]], bump = receiver_wallet.bump)]
    pub receiver_wallet: Account<'info, Wallet>,
    pub owner: Signer<'info>,
    pub system_program: Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Transfer SPL tokens between wallets
#[derive(Accounts)]
pub struct TransferToken<'info> {
    // Wallets
    #[account(mut,
        seeds = [b"wallet", &sender_wallet.sim_hash[..]],
        bump   = sender_wallet.bump,
        has_one = owner)]
    pub sender_wallet: Account<'info, Wallet>,
    #[account(mut,
        seeds = [b"wallet", &receiver_wallet.sim_hash[..]],
        bump   = receiver_wallet.bump)]
    pub receiver_wallet: Account<'info, Wallet>,

    // Token accounts
    #[account(init_if_needed,
        payer        = relayer,
        associated_token::mint      = mint,
        associated_token::authority = sender_wallet)]
    pub sender_ata: Account<'info, TokenAccount>,

    #[account(init_if_needed,
        payer        = relayer,
        associated_token::mint      = mint,
        associated_token::authority = receiver_wallet)]
    pub receiver_ata: Account<'info, TokenAccount>,

    // Mint & Registry
    pub mint: Account<'info, Mint>,
    #[account(seeds = [b"mint_registry"], bump)]
    pub registry: Account<'info, MintRegistry>,

    // Signers / programs
    pub owner:   Signer<'info>,
    #[account(mut)] pub relayer: Signer<'info>,
    pub token_program:           Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program:           Program<'info, System>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

/// Initialize the global mint registry
#[derive(Accounts)]
pub struct InitializeRegistry<'info> {
    #[account(
        init,
        payer   = admin,
        space   = MintRegistry::INIT_SPACE,
        seeds   = [b"mint_registry"],
        bump
    )]
    pub registry: Account<'info, MintRegistry>,
    #[account(mut)] pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
    /// CHECK: sysvar instructions account for CPI guard
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Create the SIM native SPL mint and whitelist it
#[derive(Accounts)]
pub struct CreateSimMint<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        init_if_needed,
        payer = admin,
        mint::decimals = 6,
        mint::authority = admin,
        mint::freeze_authority = admin,
    )]
    pub sim_mint: Account<'info, Mint>,
    /// NOW REQUIRES registry already exists
    #[account(
        mut,
        seeds = [b"mint_registry"],
        bump   = registry.bump,
        has_one = admin  // ensures only the admin who initialized can use it
    )]
    pub registry: Account<'info, MintRegistry>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
    /// CHECK: sysvar instructions account
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Modify mint registry (admin only)
#[derive(Accounts)]
pub struct ModifyRegistry<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        mut,
        seeds = [b"mint_registry"],
        bump   = registry.bump,
        has_one = admin
    )]
    pub registry: Account<'info, MintRegistry>,
    /// CHECK: sysvar instructions account
    #[account(address = sysvar::instructions::ID)]
    pub instructions: AccountInfo<'info>,
}

/// Validate PIN against stored hash
#[derive(Accounts)]
pub struct ValidatePin<'info> {
    #[account(seeds = [b"wallet", &wallet.sim_hash[..]], bump = wallet.bump)]
    pub wallet: Account<'info, Wallet>,
}

/// Check wallet balance (view function)
#[derive(Accounts)]
pub struct CheckBalance<'info> {
    #[account(seeds = [b"wallet", &wallet.sim_hash[..]], bump = wallet.bump)]
    pub wallet: Account<'info, Wallet>,
}

/// Health check for system monitoring
#[derive(Accounts)]
pub struct HealthCheck<'info> {
    #[account(seeds = [b"mint_registry"], bump)]
    pub registry: Account<'info, MintRegistry>,
}

/// Close alias index PDA and reclaim rent
#[derive(Accounts)]
#[instruction(alias: [u8; 32])]
pub struct CloseAliasIndex<'info> {
    #[account(
        mut,
        seeds = [b"alias", &alias[..]],
        bump,
        close = destination
    )]
    pub alias_index: Account<'info, AliasIndex>,
    /// CHECK: Destination for rent reclamation
    #[account(mut)]
    pub destination: AccountInfo<'info>,
    /// CHECK: sysvar instructions account is required for CPI guard; Anchor does not check this account type
    #[account(address = sysvar::instructions::ID)] pub instructions: AccountInfo<'info>,
}

// ── Account Structs ───────────────────────────────────────────────────
#[account]
pub struct Config {
    pub admin: Pubkey,
    pub salt: Vec<u8>,
    pub bump: u8,
}

impl Config {
    pub const INIT_SPACE: usize = 8 + 32 + 4 + 32 + 1; // 77 bytes (removed 16 bytes for version)
}

#[account]
pub struct Wallet {
    pub sim_hash: [u8; 32],
    pub owner:    Pubkey,
    pub pin_hash: [u8; 32],
    pub bump:     u8,
    pub alias:    [u8; 32],
    // pub version:  [u8; 16], // Removed
}

impl Wallet {
    // Updated space calculation
    pub const INIT_SPACE: usize = 8 + 32 + 32 + 32 + 1 + 32; // 137 bytes
}

#[account]
pub struct MintRegistry {
    pub admin:    Pubkey,
    pub approved: Vec<Pubkey>,
    pub bump:     u8,
    pub wallet_count: u64, // Track total wallets for health check
    // pub version:  [u8; 16], // Removed
}

impl MintRegistry {
    pub const INIT_SPACE: usize = 8 + 32 + 4 + 32 * 16 + 1 + 8; // 553 bytes (increased from 8 to 16 mints)
    
    pub fn audit_space() {
        // This function exists to help with space calculations
        // The actual space is calculated in INIT_SPACE constant
    }
}

/// Alias index account for scalable alias uniqueness checking
/// Maps alias → wallet for O(1) alias collision detection
#[account]
pub struct AliasIndex {
    /// The wallet PDA that this alias points to
    pub wallet: Pubkey,
}

impl AliasIndex {
    pub const INIT_SPACE: usize = 8 + 32; // 40 bytes (discriminator + wallet Pubkey)
}

// ── Error Types ───────────────────────────────────────────────────────
#[error_code]
pub enum SimchainError {
    #[msg("Invalid amount")]              InvalidAmount,
    #[msg("Insufficient balance")]        InsufficientBalance,
    #[msg("Unauthorized")]                Unauthorized,
    #[msg("Weak PIN")]                    WeakPin,
    #[msg("CPI not allowed")]             CpiNotAllowed,
    #[msg("Mint not approved in registry")] MintNotApproved,
    #[msg("Invalid alias")]               InvalidAlias,
    #[msg("Alias already exists")]        AliasAlreadyExists,
    #[msg("Invalid salt length")]        InvalidSaltLength,
    #[msg("Wallet count overflow")]      WalletCountOverflow,
    #[msg("Wallet count underflow")]     WalletCountUnderflow,
    #[msg("Mint already approved")]       MintAlreadyApproved,
}